<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>

















  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
  <link type="text/css" href="css/styles.css" rel="stylesheet">
  <link type="image/x-icon" href="logo.ico" rel="shortcut icon"><title>The Parallel Task Tutorial - Home</title>
  
  <meta content="Nasser Giacaman" name="AUTHOR">
  <meta content="University of Auckland, desktop, parallelization, parallelisation, Parallel Task, Nasser Giacaman, Oliver Sinnen" name="KEYWORDS"></head><body>
<table style="background-color: rgb(14, 87, 21); width: 800px; height: 170px; text-align: left; margin-left: auto; margin-right: auto;" border="2" cellpadding="10" cellspacing="5">

  <tbody>
    <tr style="color: rgb(6, 155, 48);" class="logo">
      <td style="height: 75px; padding-left: 25px; text-align: center; background-color: rgb(255, 255, 153);" class="logo" background="images/bg.jpg">
      <h1>Parallel Task<br>
      </h1>
      <h2 style="text-align: center; color: rgb(0, 102, 0);">Version
0.9, May 2010<br>
      </h2>
      </td>
    </tr>
    <tr>
      <td style="background-color: rgb(255, 255, 204);">Here you will
find
background information motivating Parallel Task (short ParaTask), as well
as some examples to illustrate the&nbsp;numerous features it provides.<br>
      <ul>
        <li>1. &nbsp;<a href="#1_Motivation">Motivation and Background<br>
</a></li>
        <ul>
          <li>1.1&nbsp; <a href="#1.1_Why_multithreading">Why multi-threading?</a></li>
          <li>1.2&nbsp; <a href="#1.2_GUI">Graphical user interfaces</a></li></ul>
        <li>2.&nbsp; <a href="#2_ParaTask">Parallel Task</a></li>
        <ul>
          <li>2.1&nbsp; <a href="#2.1_Model_overview">Model overview</a></li>
          <li>2.2&nbsp; <a href="#2.2_Example_1">Example 1: Hello, World!</a></li>
          <li>2.3&nbsp; <a href="#2.3_Example_2">Example 2: Let's get surfing!</a></li>
          <li>2.4&nbsp; <a href="#2.4_Example_3">Example 3: Building a house (GUI)</a></li>
        </ul>
        <li>3.&nbsp; <a href="#3_Further_information">Downloads and further information</a></li>
        <li>4.&nbsp; <a href="#4_People">People</a><br>
        </li>

</ul><br>

      
      <h2><a name="1_Motivation"></a>1. Motivation and Background<br>
      </h2>

      <h3><a name="1.1_Why_multithreading"></a>1.1&nbsp; Why multi-threading?</h3>
      <div style="text-align: justify;">There
are two reasons why programmers may wish to multi-thread their desktop
applications: to improve performance, and to improve responsiveness.
ParaTask allows programmers to easily achieve both these goals.<br>
      <br>
      <span style="text-decoration: underline; font-style: italic;">Improving performance</span><br>
      <br>
Parallel
computing has arrived to mainstream desktop systems in the form of
multi-core processors because of the difficulties in maintaining
improvements in uni-processor clock-speed. Unfortunately, users will
not automatically witness any performance improvements unless their applications are
parallelised. Parallel computing is however notoriously difficult,
especially in terms of program correctness and high performance.<br>
      <br>
      <span style="text-decoration: underline; font-style: italic;">Improving responsiveness</span><br>
      <br>
Multi-threading, however, is also necessary even when desktop
applications are to be run on a uni-processor. How many times have you
experienced unresponsive applications where&nbsp; buttons don't respond
no matter how many times you click? Then you drag the application
window around and it stays grey until it finishes its current job? Such
frustrating applications are not multi-threaded: there is only one
thread doing all the work.<br>
      <span style="text-decoration: underline; font-style: italic;"></span><br>
      </div>
      <h3><a name="1.2_GUI"></a>1.2&nbsp;
Graphical user interfaces</h3>
      <div style="text-align: justify;">Desktop applications allow
users to interact through a graphical user interface (GUI). The
application displays a range of visual components, some acting as a
form of input (e.g. buttons, text fields) while others display
application status (e.g. labels, progress bars). Such an application
would be based on the event-driven paradigm, where the program's
execution flow is determined by <span style="font-style: italic;">events</span> (e.g. mouse clicks, messages from other threads).<br>
      <br>
      <div style="text-align: justify;">The figure below shows the
structure of a typical multi-threaded GUI
application, which is traditionally developed using a GUI toolkit and
threading library. Two threads are in play. The most important thread,
the GUI thread (also known as event dispatch thread in Java), is solely
responsible for accessing the GUI components and responding to events.<br>
      <br>
      </div>
      </div>
      <br>
      <div style="text-align: center;"><img style="width: 720px; height: 437px;" alt="Typical structure of a multi-threaded graphical user interface application" src="images/gui_app_structure.png"><br>
      </div>
      <br>
      <div style="text-align: justify;"><br>
An important aspect of these applications is the <span style="font-style: italic;">event
loop</span>, waiting for events to arrive (1). The events are then dispatched to
the appropriate <span style="font-style: italic;">event handler</span>
to take the appropriate action (2). Many toolkits are available for
programmers to ease the development of these event-based applications.
The toolkits provide many graphical components as well as the event
loop and event handling. Generally, programmers only need to specify
the logic of event handlers (e.g. the response to a certain button
being clicked).<br>
      <br>
Programmers must ensure that these event handlers are short so that
control returns to the event loop. Otherwise, events will backlog and
the application appears unresponsive (for example, GUI applications
appear to &#8220;freeze&#8221; when the GUI does not refresh). For this reason, all
time-consuming tasks must be dispatched to a helper thread (3) to allow
the
GUI thread to return to the event loop (1) to respond to other events.
In the meantime, the helper thread executes the computation (4). Notice
that the purpose of multi-threading so far has been solely to improve
the application's responsiveness (rather than
improve performance through parallelism).<br>
      </div>
      <br>
      <div style="text-align: justify;"> Combined with the performance
versus programmability trade-off toolkit implementers face, GUI
toolkits are typically single-threaded). Only one dedicated thread is
allowed to access the GUI components: the GUI thread. In particular,
this means the helper thread (or any other thread for that matter) must not access the GUI components
directly (5). Instead, the helper thread posts an event (6) to the GUI thread, which in turn updates the GUI (1), (2), (7).<br>
      <br>
In developing multi-threaded applications to improve performance and/or
responsiveness, programmers must adhere to the above rules. ParaTask
allows programmers to develop interactive <span style="font-style: italic;">and</span> performant multi-threaded applications by simplifying the parallel development process. 
      </div>
      
<br>

      <br>

      <h2><a name="2_ParaTask"></a>2. &nbsp;Parallel
Task</h2>

      
      <h3><a name="2.1_Model_overview"></a>2.1&nbsp; Model overview</h3>
      <div style="text-align: justify;">In analysing threading and
concurrent programs, various task concepts can be identified. Some
tasks have short runtimes and are computationally intensive; other
tasks have long runtimes and are interactive (i.e. react to
input/output). Some tasks execute once, while others need to be
executed multiple times. Different task types are therefore supported
by ParaTask, all unified in a single model: <br>
      <br>
      </div>
      <div style="text-align: justify; margin-left: 40px;"><span style="font-style: italic;">&#8226; One-off tasks:</span>
These tasks are CPU-bound computations. When invoked, a single instance
of the task is enqueued to be executed from start to finish by any of
the processors. </div>
      <div style="margin-left: 40px;"><br>
      </div>
      <div style="text-align: justify; margin-left: 40px;"><span style="font-style: italic;">&#8226; Multi-tasks:</span> These are multiple tasks for data parallelism, hence they map to different processors. <br>
      </div>
      <div style="margin-left: 40px;"><br>
      </div>
      <div style="text-align: justify; margin-left: 40px;"><span style="font-style: italic;">&#8226; Interactive tasks:</span>
These tasks are I/O-bound computations, for example background tasks
waiting for events (e.g. mouse or key press). They should not be
defined as one-off tasks since they would cause a backlog of
ready-to-execute tasks. Many tasks are perfect candidates for
interactive tasks, for example web-based tasks. These tasks correspond
to classical threads. <br>
      </div>
      <br>
      <h2>
      </h2>


      
      <h3><a name="2.2_Example_1"></a>2.2&nbsp; Example 1: Hello, World!</h3>
      <div style="text-align: justify;">No
introduction would be
complete without the notorious Hello, World! Here, we illustrate
examples of one-off tasks, multi-tasks and interactive tasks (<a href="examples/hello.zip">download
example here</a>). We will explain the code in snippets. The first method,
hello(), is straightforward:<br>
<span style="font-weight: bold;"></span><br>
&nbsp;&nbsp;&nbsp; public static void hello(String name) {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println("Hello from "+name);<br>
&nbsp;&nbsp;&nbsp; }<br>
      <span style="font-weight: bold;"></span></div>
      <br>
      <div style="text-align: justify;">The next methods of interest
are task_hello(), multi_hello() and interactive_hello(). These
correspond to one-off tasks, multi-tasks and interactive tasks
respectively: <br>
      <br>
&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">TASK</span> public static void task_hello() {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; hello("Task");<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">TASK(*)</span> public static void multi_hello() {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; hello("Multi-Task [subtask "+CurrentTask.relativeID()+"]");<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">INTERACTIVE_TASK</span> public static void interactive_hello() {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; hello("Interactive Task");<br>
&nbsp;&nbsp;&nbsp; }<br>
      <br>
The first thing you'll notice is an excellent example of code reuse;
here, these methods reuse the sequential code by calling hello(). The
second thing to notice is that these 3 methods are almost identical;
the only difference is the slight change in the TASK modifier. Now it
is time to invoke these methods! <br>
      <br>
      <big><big><span style="color: rgb(102, 102, 102); font-family: monospace;">&nbsp;&nbsp;&nbsp; System.out.println("(1)");</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; hello("Sequential");</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;</span><span style="color: rgb(102, 102, 102); font-family: monospace;">&nbsp; System.out.println("(2)");</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; TaskID id1 = task_hello();</span><br style="font-family: monospace;">
      <span style="color: rgb(102, 102, 102); font-family: monospace;">&nbsp;&nbsp;&nbsp; System.out.println("(3)");</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; TaskIDGroup id2 = multi_hello();</span><br style="font-family: monospace;">
      <span style="color: rgb(102, 102, 102); font-family: monospace;">&nbsp;&nbsp;&nbsp; System.out.println("(4)");</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; TaskID id3 = interactive_hello();</span><br style="font-family: monospace;">
      <span style="color: rgb(102, 102, 102); font-family: monospace;">&nbsp;&nbsp;&nbsp; System.out.println("(5)");</span></big></big><br>
      <br>
Recall that hello() is a standard sequential method. The 3 task methods
however have been annotated with a variant of the TASK keyword.
Consequently, these 3 methods will now return a TaskID corresponding to
a respective invocation of that task. Since execution of a task is
asynchronous to it's caller, we need to synchronise with the task
completion. One approach is to place the TaskIDs of these tasks inside
a group and wait for the group to finish:<br>
      <br>
      <big><big><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; TaskIDGroup g = new TaskIDGroup(3);</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; g.add(id1);</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; g.add(id2);</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; g.add(id3);</span><br style="font-family: monospace;">
      <span style="color: rgb(102, 102, 102); font-family: monospace;">&nbsp;&nbsp;&nbsp; System.out.println("** Going to wait for the tasks...");<br>
      </span><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; g.waitTillFinished();</span><span style="color: rgb(102, 102, 102); font-family: monospace;"></span><br style="font-family: monospace;">
      </big></big><span style="color: rgb(102, 102, 102);"><big><big><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; System.out.println("** Done! All tasks have now completed.");</span></big></big><br>
      </span><br>
Here is one possible output produced by this program:<br>
      <br>
      <div style="margin-left: 40px;"><span style="color: rgb(0, 0, 153);">(1)</span><br style="color: rgb(0, 0, 153);">
      <span style="color: rgb(0, 0, 153);">Hello from Sequential</span><br style="color: rgb(0, 0, 153);">
      <span style="color: rgb(0, 0, 153);">(2)</span><br style="color: rgb(0, 0, 153);">
      <span style="color: rgb(0, 0, 153);">(3)</span><br style="color: rgb(0, 0, 153);">
      <span style="color: rgb(0, 0, 153);">Hello from Task</span><br style="color: rgb(0, 0, 153);">
      <span style="color: rgb(0, 0, 153);">(4)</span><br style="color: rgb(0, 0, 153);">
      <span style="color: rgb(0, 0, 153);">(5)</span><br style="color: rgb(0, 0, 153);">
      <span style="color: rgb(0, 0, 153);">** Going to wait for the tasks to execute... </span><br style="color: rgb(0, 0, 153);">
      <span style="color: rgb(0, 0, 153);">Hello from Interactive Task</span><br style="color: rgb(0, 0, 153);">
      <span style="color: rgb(0, 0, 153);">Hello from Multi-Task [subtask 0]</span><br style="color: rgb(0, 0, 153);">
      <span style="color: rgb(0, 0, 153);">Hello from Multi-Task [subtask 1]</span><br style="color: rgb(0, 0, 153);">
      <span style="color: rgb(0, 0, 153);">** Done! All tasks have now completed.</span><br>
      </div>
      <br>
The important thing to notice is how the tasks executed asynchronously
with their caller. This is obvious since the statement following the
task's invocation (i.e. "(2)", .. "(5)") were all executed before the
actual task computation of the respective task. <br>
&nbsp;&nbsp;&nbsp; From this example, it may seem unclear what the
difference is between interactive and one-off tasks. This is because
the difference between the 2 did not have an effect in this particular
example (but will be illustrated in the following example). The
difference with the multi-task is more obvious: the task is executed
multiple times.<br>
      <span style="font-weight: bold;"><br>
      </span></div>
      <h3><a name="2.3_Example_2"></a>2.3&nbsp; Example 2: Let's get surfing!<br>
</h3>
      <div style="text-align: justify;">In this example, we will access the web to illustrate the difference between the
task types (<a href="examples/wiki.zip">download
example here</a>).
Therefore, this example requires you are connected to a network in
order to run! This example illustrates the difference between
sequential methods, one-off tasks, multi-tasks and interactive tasks by
running the same set of computations under each of the cases. First,
the sequential code for one computation:<br>
      <br>
      <div style="margin-left: 40px;"><big><big><span style="font-family: monospace;">public static void webAccess(String address) {</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; ...</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp; &nbsp; // count number of links<br>
&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp; // print the time for this computation</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; ...</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">}</span></big></big><br>
      </div>
      <br>
First, we create a collection to store all the addresses we wish to access:<br>
      <br>
      <div style="margin-left: 40px; font-family: monospace;">
      <div style="text-align: left;"><big><big>ConcurrentLinkedQueue&lt;String&gt; urls = <br>
      </big></big>
      <div style="text-align: right;"><big><big>new ConcurrentLinkedQueue&lt;String&gt;();</big></big><br>
      </div>
      </div>
      <big><big>
urls.add("http://en.wikipedia.org/wiki/New_Zealand");<br>

...<br>
urls.add("http://en.wikipedia.org/wiki/Tongariro_National_Park");<br>
      </big></big></div>
      <br>
      <span style="text-decoration: underline;">Sequential:</span><br>
      <br>
Below is the sequential code:<br>
      <br>
      <div style="margin-left: 40px;"><big><big><span style="font-family: monospace;">for(String s: urls) {</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; webAccess(s);</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">}</span><br style="font-family: monospace;">
      <span style="color: rgb(102, 102, 102); font-family: monospace;">System.out.println("Total time: "+time+" seconds.");</span></big></big><br>
      </div>
      <br>
 </div>And here is an example of the output for the sequential code:<br>
      <br>
      <div style="margin-left: 40px;"><span style="color: rgb(51, 0, 153);">830 links for 'New_Zealand' [11.921 seconds, thread 1]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">509 links for 'Auckland' [0.415 seconds, thread 1]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">202 links for 'Rotorua' [0.209 seconds, thread 1]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">127 links for 'Milford_Sound' [0.21 seconds, thread 1]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">524 links for 'Christchurch' [0.613 seconds, thread 1]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">467 links for 'Dunedin' [1.971 seconds, thread 1]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">152 links for 'Queenstown,_New_Zealand' [0.402 seconds, thread 1]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">149 links for 'Tongariro_National_Park' [0.407 seconds, thread 1]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">Total time: 16.159 seconds.</span><br>
      </div>
      <br>
      <div style="text-align: justify;">The
actual times of the
computations is not important (since the execution times vary depending
on the network). What is important is the relationship between the
individual times and the total time. In this case, all the computations
were executed sequentially by the same thread (thread 1), therefore the
total time is the sum of the individual times.In the case of a GUI
application, this means that the application would remain "frozen" for
16 seconds! <br>
      <br>
      <span style="text-decoration: underline;">One-off tasks:</span><br>

      <br>
The first step involves defining the task. To promote code-reuse, we
implement this as a wrapper around the sequential method since
webAccess() is thread-safe independent code:<br>
      <br>
      <div style="margin-left: 40px;"><big><big><span style="font-family: monospace;"><span style="font-weight: bold;">TASK</span> public static void webAccessTask(String address) {</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; webAccess(address);</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">}</span></big></big><br>
      <br>
      </div>
After invoking the tasks, we add the individual TaskIDs to a group and synchronise on the group:<br>
      <br>
      <div style="margin-left: 40px;"><big><big><span style="font-family: monospace;">TaskIDGroup g = new TaskIDGroup(urls.size());</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">for(String s: urls) {</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; TaskID id = webAccessTask(s);</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; g.add(id);</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">}</span><span style="font-family: monospace;"></span><br style="font-family: monospace;">
      <span style="font-family: monospace;">g.waitTillFinished();</span><big style="font-family: monospace;"><big><br>
      <small><small><span style="color: rgb(102, 102, 102);">System.out.println("Total time: "+time+" seconds.");</span></small></small></big></big></big></big><br>
      <br>
      </div>
And the output produced:<br>
      <br>
      <div style="margin-left: 40px;"><span style="color: rgb(51, 0, 153);">509 links for 'Auckland' [1.682 seconds, thread 7]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">202 links for 'Rotorua' [0.415 seconds, thread 7]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">830 links for 'New_Zealand' [3.106 seconds, thread 8]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">127 links for 'Milford_Sound' [0.21 seconds, thread 7]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">524 links for 'Christchurch' [1.804 seconds, thread 8]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">152 links for 'Queenstown,_New_Zealand' [2.024 seconds, thread 8]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">467 links for 'Dunedin' [1.569 seconds, thread 7]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">149 links for 'Tongariro_National_Park' [0.203 seconds, thread 7]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">Total time: 6.994 seconds.</span><br>
      </div>
      <br>
Again, the actual individual times are not important. What we are
interested in now is that the tasks were executed by a team of 2 worker
threads (thread 7 and thread 8). As a result, the total time is a sum
of the longest sum of times that one of the worker threads encounters.
In this case, the 3 tasks executed by thread 8 took a total of 6.9
seconds.<br>
&nbsp;&nbsp;&nbsp;&nbsp; For most computations, one-off tasks will be
the right solution. But in this particular application, one-off tasks
are probably not the best solution. Even though one-off tasks have
allowed us to reduce the total time (since multiple worker threads are
sharing the workload), we notice that webAccess() is not
compute-intensive. The better solution would be interactive tasks (see
below)!<br>
      <br>

      <span style="text-decoration: underline;">Multi-tasks:</span><br>

      <br>
Multi-tasks are essentially one-off tasks, except they are executed
multiple times! In particular, multi-tasks are still shared amongst a
fixed number of worker threads. Below is a multi-task solution:<br>
      <br>
      <div style="text-align: right;">
      <div style="text-align: left;"><big><big><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">TASK(*)</span> public static void</span></big></big><big><big><span style="font-family: monospace;"> webAccessMulti(</span></big></big><br>
      <big><big><span style="font-family: monospace;"></span></big></big></div>
      <big><big><span style="font-family: monospace;">ConcurrentLinkedQueue&lt;String&gt; queue) {</span></big></big><br style="font-family: monospace;">
      </div>
      <big><big><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; String s = null;</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while ((s = queue.poll()) != null)</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; webAccess(s);</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span></big></big><br>
      <br>
The difference here is that the entire collection is passed to the
multi-task. Since this task is executed multiple times, each subtask
will remove (from the concurrent collection) a url to access. The
advantage of multi-tasks is that subtasks are automatically placed in a
group and subtasks have group awareness (e.g. they could use a barrier,
or inquire about their relative position within the group, etc).
Executing the multi-task is easy:<br>
      <big><big><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; TaskIDGroup g = webAccessMulti(urls);</span><span style="font-family: monospace;"></span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; g.waitTillFinished();</span></big><big><span style="font-family: monospace;"></span><big style="font-family: monospace;"><big><br>
<small><small><span style="color: rgb(102, 102, 102);">&nbsp;&nbsp;&nbsp; System.out.println("Total time: "+time+" seconds.");</span></small></small></big></big></big></big><br>
      <br>
In this application, the output from a multi-task would be the same as
the one-off tasks above. This is because one-off tasks and multi-tasks
are eventually all executed on a fixed number of worker threads.
However, multi-tasks generally simplify the writing of data-parallel
code (e.g. in this case, a TaskIDGroup is automatically returned
containing all the individual TaskIDs).<br>
      <br>

      <span style="text-decoration: underline;">Interactive tasks:</span><br>
      <br>
Although one-off tasks will be the most common and useful in ParaTask,
they are not ideal for this particular example. This is because
webAccess() is not compute-intensive. As such, the worker threads spend
a lot of time waiting for result from the network. This is where
interactive tasks are best suited: for computations that involve
external input/output. <br>
      <br>
      <big><big><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">INTERACTIVE_TASK</span> public static void webAccessInteractiveTask<br>
      </span></big></big>
      <div style="text-align: right;"><big><big><span style="font-family: monospace;">&nbsp;(String address) {</span></big></big><br style="font-family: monospace;">
      </div>
      <big><big><span style="font-family: monospace;">
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; webAccess(address);</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">
&nbsp;&nbsp;&nbsp; }</span></big></big><br>
      <br>
Interactive tasks are invoked exactly like the one-off tasks above,
except that the tasks are not queued to be shared by the existing
threadpool. Instead, each of the tasks is mapped to its own thread.
This is the behaviour we desire, since these computations are not
compute intensive, we prefer to have extra threads if it means the
tasks are truly all executed concurrently. Having this distinction of
interactive tasks will also help other compute-intensive tasks, since
the worker threads will remain busy executing (as opposed to blocking
waiting for input/output). Here is the result:<br>
&nbsp;&nbsp;&nbsp; <br>
      <div style="margin-left: 40px;"><span style="color: rgb(51, 0, 153);">127 links for 'Milford_Sound' [1.069 seconds, thread 13]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">149 links for 'Tongariro_National_Park' [1.26 seconds, thread 17]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">152 links for 'Queenstown,_New_Zealand' [1.263 seconds, thread 16]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">202 links for 'Rotorua' [1.437 seconds, thread 11]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">524 links for 'Christchurch' [1.694 seconds, thread 14]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">467 links for 'Dunedin' [1.734 seconds, thread 15]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">509 links for 'Auckland' [1.917 seconds, thread 10]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">830 links for 'New_Zealand' [2.134 seconds, thread 9]</span><br style="color: rgb(51, 0, 153);">
      <span style="color: rgb(51, 0, 153);">Total time: 2.16 seconds.</span><br>
      </div>
      <br>
Notice how each of the tasks was executed by a different thread.
Therefore, the total time is essentially the time of the longest task.<br>
      <br>
<br>
      </div>


      <h3><a name="2.4_Example_3"></a>2.4&nbsp; Example 3: Building a house (GUI)<br>
</h3>
      <div style="text-align: justify;">The final example is that of a
GUI application. The motivation here is to illustrate the problem
discussed above where the application appears to "freeze" and become
unresponsive when it is not multi-threaded. Before having a look at the
code, <a href="examples/house.jar">download and run the application</a> (&gt; java -cp house.jar:PTRuntime.jar house.Build). The source code can also be <a href="examples/house.zip">downloaded here</a>.<br>
&nbsp;&nbsp;&nbsp; On the left side, the user is able to select a
colour for the roof and walls of a house being built. The "build"
button actually builds the house, and the user is able to "clear" the
screen to delete the graphic. At the bottom of the window, the user is
able to switch the application mode (parallel mode or sequential mode).
If the house is built too quickly,select a higher level of computation
from the menu. When running the application in sequential mode, you
will notice how it freezes and cannot select any of the GUI components.
In the parallel mode however, the graphics even updates as the house
updates for a much more appealing user experience. <br>
&nbsp;&nbsp;&nbsp; Now we are ready to have a look at the interesting
parts of this application, and see where ParaTask helps. When the user
presses the build button, the application decides on the current mode.
If the current mode is sequential, then the following code is executed:<br>
      <br>
      <div style="margin-left: 40px;"><big><big><span style="font-family: monospace;">houseApplet.build(colorWalls, colorRoof);</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">Build.this.finishedBuilding();</span></big></big><br>
      </div>
      <br>
The finishedBuilding() method refers to computations that will update
the GUI after the house is built. If the current mode is parallel, then
the following code is executed:<br>
      <br>
      <div style="margin-left: 40px;"><big><big><span style="font-family: monospace;">TaskID id = houseApplet.buildTask(colorWalls, colorRoof) </span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">notify</span>(Build.this::finishedBuilding());</span></big></big><br>
      </div>
      <br>
You will notice that the parallel code using ParaTask is very similar
to the sequential code. One difference, of course, is that the
buildTask() method called is a TASK rather than a standard sequential
method. Because of the asynchronous nature of tasks, we need a way to
specify that the finishedBuilding() method be invoked after the task
completes. More specifically, the finishedBuilding() method must be
invoked by the GUI thread (i.e. Java's event dispatch thread). This is
what the notify clause assures. We specify that the finishedBuilding()
method is to be executed by the same thread that enqueued the task (in
this case, it is the EDT since we are inside the actionPerformed()
method). This is what allows the EDT to return to the event loop and
maintain a responsive application.<br>
      <br>
      <span style="text-decoration: underline;">Nested parallelism and dependences</span><br>
      <br>
When the application is run in parallel mode, you will notice the house
is being built in parallel (when using a multi-core system). From the
above code, it seems we only have one task (buildTask()). In actual
fact, the buildTask() task creates further tasks and waits for them to
complete. However, these smaller parts of the house need to be developed using a
particular order. Here is the relationship between these tasks:<br>
      <br>
      <div style="text-align: center;"><img style="width: 673px; height: 389px;" alt="Dependence graph amongst tasks for building the house" src="images/houseDependences.png"><br>

      </div>
</div>

      <br>
      <br>
      <div style="text-align: justify;">From this diagram, we see that
the foundation, walls, roof tiles and windows are modelled as
multi-tasks. The door and sale sign are standard one-off tasks. The
first stage of building the house is laying the foundation. Once the
foundation is complete, the walls may be constructed, and then the roof
tiles. Only after the roof is complete may the door and windows be
constructed. Finally, when all the house is completed, the sale sign is
erected. One possibility of defining these tasks is as follows:<br>
      <br>
      <div style="text-align: left;"><big><big><span style="font-family: monospace;">TASK(*) public void buildFoundation(ConcurrentLinkedQueue tiles) {</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; Tile t = null;</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; while ((t = tiles.poll()) != null) {</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  buildTile(t);</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">}</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">
TASK(*) public void buildWalls(ConcurrentLinkedQueue sidings) {...}</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">

TASK(*) public void buildRoofTiles(ConcurrentLinkedQueue tiles) {...}</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">TASK public void buildDoor(Door d) {...}</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">

TASK(*) public void buildWindows(ConcurrentLinkedQueue windows) {...}</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">
TASK public void buildSign(Sign s) {...}</span></big></big><br>
      </div>
      <br>
Notice that each of these tasks possesses no knowledge of any other
task. In other words, they are decoupled. This is an important software
engineering principle, as it will minimises future code change if any
of the tasks are modified or removed. However, we cannot simply just
invoke all these tasks immediate one after another as this means the
dependences might not be met (for example if the wall is executed
before all the foundation tasks are completed). At the same time we
don't want to block after invoking each set of tasks, as this might
reduce the parallelism and also blocks the GUI thread. The solution is
to use the dependsOn clause:<br>
      <br>
      <big><big><span style="font-family: monospace;">
TaskID idFoundation = buildFoundation(foundationTiles);</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">

TaskID idWalls = buildWalls(wallSides) <span style="font-weight: bold;">dependsOn</span>(idFoundation);</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">

TaskID idRoof = buildRoofTiles(roofTiles) <span style="font-weight: bold;">dependsOn</span>(idWalls);</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">

TaskID idDoor = buildDoor(door) <span style="font-weight: bold;">dependsOn</span>(idRoof);</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">

TaskID idWindows = buildWindows(windows) <span style="font-weight: bold;">dependsOn</span>(idRoof);</span><br style="font-family: monospace;">
      <span style="font-family: monospace;">

TaskID idSign = buildSign(sign) <span style="font-weight: bold;">dependsOn</span>(idDoor, idWindows);</span></big></big><br>
      <br>
At the end of this set of 6 statements, the GUI thread is free to
return to the event loop to process other application events. In the
meantime, all the tasks have been enqueued. Each task is executed as
soon as a worker thread is free, but only if it's dependences have been
met. For example, none of the roof tasks will be executed until all the
wall tasks have completed. Similarly, the final sign task will wait for
both the door and windows to be completed.<br>
&nbsp;&nbsp;&nbsp; Not only is the dependsOn clause intuitive and easy
to use, but it also keeps the tasks decoupled from each other. Assume
that another house is to be built, but it has different ordering
constraints. For example, maybe the windows and doors are to be built
before the roof completes, and the the sign may be placed earlier on.
In this case, the programmer only needs to update the corresponding
dependsOn clause. The user code of the tasks need not be modified! If
the programmer was implementing dependences manually (e.g. using wait
conditions from a threading library), then this would have required
modification to the task code!<br>
      </div>

      <h2><a name="3_Further_information"></a>3. &nbsp;Downloads and
further information</h2><br>
      
      <ul>
      </ul>
      <h2><a name="4_People"></a>4. &nbsp;People</h2>
      <ul></ul>
      <br>

      
      </td>
    </tr>

  </tbody>
</table>

<br>

<br>
</body></html>