package paratask.test;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.concurrent.ConcurrentLinkedQueue;

import javax.swing.JApplet;

public class House extends JApplet {
	
	private Build builder;
	
	private int width = 500;
	private int height = 320;
	
	private int N = 20;
	private boolean clearScreen = true;
	
	private ArrayList<BuildingMaterial> foundation = new ArrayList<BuildingMaterial>();
	private ArrayList<BuildingMaterial> wallSiding = new ArrayList<BuildingMaterial>();
	private ArrayList<BuildingMaterial> roofTiles = new ArrayList<BuildingMaterial>();
	private ArrayList<BuildingMaterial> windows = new ArrayList<BuildingMaterial>();
	private BuildingMaterial door = null;
	private BuildingMaterial forSaleSign = null;
	
	private Color colorRoof;
	private Color colorWalls;
	
	public House(Build builder) {
		this.builder = builder;
		setPreferredSize(new Dimension(width, height));
		initFoundation();
		initWallSiding();
		initRoofTiles();
		initWindowsAndDoor();
		initForSaleSign();
	}
	
	TASK(*) private void buildAllTask(ConcurrentLinkedQueue<BuildingMaterial> items) {
		BuildingMaterial b = null;
		  
		while ((b = items.poll())!= null) {
			buildItem(b);
		}
	}
	
	private void buildAll(ArrayList<BuildingMaterial> items) {
		BuildingMaterial b = null;
		Iterator<BuildingMaterial> it = items.iterator();
		while (it.hasNext()) {
			buildItem(it.next());
		}
	}
	
	TASK public void buildTask(Color colorWalls, Color colorRoof) {
		this.colorWalls = colorWalls;
		this.colorRoof = colorRoof;
		
		TaskID idFoundation = buildAllTask(new ConcurrentLinkedQueue<BuildingMaterial>(foundation));
		TaskID idWalls = buildAllTask(new ConcurrentLinkedQueue<BuildingMaterial>(wallSiding)) dependsOn(idFoundation);
		TaskID idRoof = buildAllTask(new ConcurrentLinkedQueue<BuildingMaterial>(roofTiles)) dependsOn(idWalls);
		TaskID idDoor = buildItemTask(door) dependsOn(idWalls);
		TaskID idWindows = buildAllTask(new ConcurrentLinkedQueue<BuildingMaterial>(windows)) dependsOn(idWalls);
		TaskID idSign = buildItemTask(forSaleSign) dependsOn(idRoof, idDoor, idWindows);
		
        try {
        	idSign.waitTillFinished();
		} catch (ExecutionException e) {
			e.printStackTrace();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
	public void build(Color colorWalls, Color colorRoof) {
		this.colorWalls = colorWalls;
		this.colorRoof = colorRoof;
		
		buildAll(foundation);
		buildAll(wallSiding);
		buildAll(roofTiles);
		buildItem(door);
		buildAll(windows);
		buildItem(forSaleSign);
	}

	TASK private void buildItemTask(BuildingMaterial item) {
		buildItem(item);
	}
	
	private void buildItem(BuildingMaterial item) {
		if(!item.isVisible()) {
			simulateWork(N);
			item.setVisible(true);
			repaint();
		}
	}
	
	public void update (  Graphics g ){
        paint(g);
	}
	
	public void paint(Graphics g) {
		
		if (clearScreen) {
			g.clearRect(0, 0, width, height);
			clearScreen = false;
		}
		
		//-- draw foundation
		for (BuildingMaterial b: foundation) {
			if (b.isVisible()) {
				g.setColor(new Color(162, 158, 24));
				g.fillRect(b.getX(), b.getY(), b.getWidth(), b.getHeight());
				g.setColor(Color.BLACK);
				g.drawRect(b.getX(), b.getY(), b.getWidth(), b.getHeight());
			}
		}
		
		//-- draw wall
		for (BuildingMaterial b: wallSiding) {
			
			if (b.isVisible()) {
				g.setColor(colorWalls);
				g.fillRect(b.getX(), b.getY(), b.getWidth(), b.getHeight());
				g.setColor(Color.BLACK);
				g.drawRect(b.getX(), b.getY(), b.getWidth(), b.getHeight());
			}
		}
		
		//-- draw roof
		for (BuildingMaterial b: roofTiles) {
			
			if (b.isVisible()) {
				g.setColor(colorRoof);
				g.fillRect(b.getX(), b.getY(), b.getWidth(), b.getHeight());
				g.setColor(Color.BLACK);
				g.drawRect(b.getX(), b.getY(), b.getWidth(), b.getHeight());
			}
		}
		
		//-- draw door
		if (door.isVisible()) {
			g.setColor(new Color(152, 118, 84));
			g.fillRect(door.getX(), door.getY(), door.getWidth(), door.getHeight());
			g.setColor(Color.BLACK);
			g.drawRect(door.getX(), door.getY(), door.getWidth(), door.getHeight());
		}
		
		//-- draw windows
		for (BuildingMaterial b: windows) {
			if (b.isVisible()) {
				g.setColor(new Color(173, 216, 230));
				g.fillRect(b.getX(), b.getY(), b.getWidth(), b.getHeight());
				g.setColor(Color.BLACK);
				g.drawRect(b.getX(), b.getY(), b.getWidth(), b.getHeight());
			}
		}
		
		//-- draw sign
		if (forSaleSign.isVisible()) {
			g.setColor(new Color(152, 118, 84));
			g.fillRect(400, 260, 15, 20);
			g.fillRect(445, 260, 15, 20);
			g.setColor(Color.BLACK);
			g.drawRect(400, 260, 15, 20);
			g.drawRect(445, 260, 15, 20);
			 
			g.setColor(new Color(255, 239, 0));
			g.fillRect(forSaleSign.getX(), forSaleSign.getY(), forSaleSign.getWidth(), forSaleSign.getHeight());
			g.setColor(Color.BLACK);
			g.drawRect(forSaleSign.getX(), forSaleSign.getY(), forSaleSign.getWidth(), forSaleSign.getHeight());
			
			Font f = g.getFont();
			g.setFont(new Font(f.getName(), Font.BOLD,21));
			g.drawString("For", forSaleSign.getX()+30, forSaleSign.getY()+30);
			g.drawString("Sale", forSaleSign.getX()+25, forSaleSign.getY()+60);
		}
	}
	
	private void initFoundation() {
		int numCols = 31;
		int w = 15; 
		int h = 10;
		
		int x = 20;
		int y = 280;
		for (int i = 0; i < numCols; i++)
			foundation.add(new BuildingMaterial(x+i*w,y,w,h, false));
		
		x-=7;
		y+=h;
		for (int i = 0; i < numCols; i++)
			foundation.add(new BuildingMaterial(x+i*w,y,w,h, false));

		x+=7;
		y+=h;
		for (int i = 0; i < numCols; i++)
			foundation.add(new BuildingMaterial(x+i*w,y,w,h, false));
		
		Collections.shuffle(foundation);
	}
	
	private void initWallSiding() {
		int numPlanks = 40;
		int totalW = 320;
		int w = totalW / numPlanks; 
		int h = 150;
		
		int x = 40;
		int y = 130;
		for (int i = 0; i < numPlanks; i++)
			wallSiding.add(new BuildingMaterial(x+i*w,y,w,h, false));

		Collections.shuffle(wallSiding);
	}
	
	private void initRoofTiles() {
		int numPlanks = 12;
		int dec = 10;
		int h = 10;
		int w = 360; 
		
		int x = 20;
		int y = 130-h;
		for (int i = 0; i < numPlanks; i++) {
			roofTiles.add(new BuildingMaterial(x+i*dec,y-i*h,w,h, false));
			w-=2*dec;
		}
		Collections.shuffle(roofTiles);
	}
	
	private void initWindowsAndDoor() {
		door = new BuildingMaterial(63,160,75,120, false);

		windows.add(new BuildingMaterial(160,160,80,60, false));
		windows.add(new BuildingMaterial(253,160,75,60, false));
	}
	
	private	 void initForSaleSign() {
		forSaleSign = new BuildingMaterial(380,180,100,80, false);
	}
	
	public void setComputationLevel(int N) {
		this.N = N;
	}
	
	public void reset() {
		clearScreen = true;
		
		for (BuildingMaterial b: foundation) {
			b.setVisible(false);
		}
		
		for (BuildingMaterial b: wallSiding) {
			b.setVisible(false);
		}
		
		for (BuildingMaterial b: roofTiles) {
			b.setVisible(false);
		}
		
		door.setVisible(false);
		
		for (BuildingMaterial b: windows) {
			b.setVisible(false);
		}
		
		forSaleSign.setVisible(false);
		repaint();
	}

	private void simulateWork(int N) {
        double xmin = -1.0;
        double ymin = -1.0;
        double width = 2.0;
        double height = 2.0;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                double x = xmin + i * width / N;
                double y = ymin + j * height / N;
                Complex z = new Complex(x, y);
                newton(z);
            }
        }
    }
	
	private Color newton(Complex z) {
        double EPSILON = 0.00000001;
        Complex four = new Complex(4, 0);
        Complex one = new Complex(1, 0);
        Complex root1 = new Complex(1, 0);
        Complex root2 = new Complex(-1, 0);
        Complex root3 = new Complex(0, 1);
        Complex root4 = new Complex(0, -1);
        for (int i = 0; i < 100; i++) {
            Complex f = z.times(z).times(z).times(z).minus(one);
            Complex fp = four.times(z).times(z).times(z);
            z = z.minus(f.divides(fp));
            if (z.minus(root1).abs() <= EPSILON) return Color.WHITE;
            if (z.minus(root2).abs() <= EPSILON) return Color.RED;
            if (z.minus(root3).abs() <= EPSILON) return Color.GREEN;
            if (z.minus(root4).abs() <= EPSILON) return Color.BLUE;
        }
        return Color.BLACK;
    }
}
