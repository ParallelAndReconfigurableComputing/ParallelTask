package pt.test;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.Random;

import pt.runtime.ParaTask.ThreadPoolType;

public class TestNestedTask4 {
	private static final int N_DATASIZE = 0;

	private static final String BM_METHOD = "execute";
	
	private static final Class<?>[] BM_METHOD_ARGUEMENT_TYPE = {int.class};

	private static final String MOL = "MOL";

	private static final String MOL_CLASS = "core.moldyn.Molcore";

	private static final String MON = "MON";

	private static final String MON_CLASS = "core.montecarlo.Moncore";

	private static final String RAY = "RAY";

	private static final String RAY_CLASS = "core.raytracer.Raycore";
	
	private static ConcurrentLinkedQueue<Benchmark> concurrentLinkedQueue = null;

	private static int totalNum;
	
	private static String benchmarkName;
	
	//Should at least 3 arguments
	//args[0] = the total number of tasks(which includes one-off task and multi-tasks)
	//args[1] = benchmark name
	public static void main(String[] args) {
		if (null == args || args.length != 2) {
			try {
				throw new Exception("Wrong arguemnts setting");
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		totalNum = Integer.valueOf(args[0]);
		benchmarkName = args[1];
		
		TaskID[] taskIDs = new TaskID[totalNum];
		TaskIDGroup tig = new TaskIDGroup(totalNum);

		long startTime = System.currentTimeMillis();
		
		for (int i = 0; i < totalNum; i++) {
			taskIDs[i] = runBM(createBenchmark(getBenchmarkClass(benchmarkName)));
		}
		
		for(int i = 0; i < totalNum; i++){
			tig.add(taskIDs[i]);
		}
		
		try {
			Thread.sleep(1000 * 10);
		} catch (InterruptedException e1) {
			e1.printStackTrace();
		}
		
		ParaTask.setThreadPoolSize(ThreadPoolType.ONEOFF, 8);
		
		try {
			Thread.sleep(1000 * 15);
		} catch (InterruptedException e1) {
			e1.printStackTrace();
		}
		
		ParaTask.setThreadPoolSize(ThreadPoolType.ONEOFF, 4);
		
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e1) {
			e1.printStackTrace();
		}
		
		ParaTask.setThreadPoolSize(ThreadPoolType.ONEOFF, 6);
		
		try {
			tig.waitTillFinished();
		} catch (ExecutionException e) {
			e.printStackTrace();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		long endTime = System.currentTimeMillis();
	}


	TASK private static void runBM(Benchmark benchmark) {
		try { 
			System.out.println("One-off Task [Thread ID "+CurrentTask.currentThreadID()+"] [Thread Local ID "+CurrentTask.currentThreadLocalID()+"] [Task Global ID "+CurrentTask.globalID()+"]  [Task Relative ID "+CurrentTask.relativeID()+"]  [Multi Task Size "+CurrentTask.multiTaskSize()+"] ");
			benchmark.getMethod().invoke(benchmark.getInstance(), benchmark.getArguments()); 
			
			TaskIDGroup tig = new TaskIDGroup(totalNum);
			TaskID[] taskIDs = new TaskID[totalNum];
			
			for (int i=0; i < totalNum; i++) {
				taskIDs[i] = runBM_1(createBenchmark(getBenchmarkClass(benchmarkName)));
			}
			
			for(int i = 0; i < totalNum; i++){
				tig.add(taskIDs[i]);
			}

			try {
				tig.waitTillFinished();
			} catch (ExecutionException e) {
				e.printStackTrace();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			
		} catch (IllegalAccessException e) { 
			e.printStackTrace(); 
		} catch (IllegalArgumentException e) { 
			e.printStackTrace(); 
		} catch (InvocationTargetException e) { 
			e.printStackTrace(); 
		} 
	}
	
	TASK private static void runBM_1(Benchmark benchmark) {
		try { 
			System.out.println("One-off Task [Thread ID "+CurrentTask.currentThreadID()+"] [Thread Local ID "+CurrentTask.currentThreadLocalID()+"] [Task Global ID "+CurrentTask.globalID()+"]  [Task Relative ID "+CurrentTask.relativeID()+"]  [Multi Task Size "+CurrentTask.multiTaskSize()+"] ");
			benchmark.getMethod().invoke(benchmark.getInstance(), benchmark.getArguments()); 
			
			TaskIDGroup tig = new TaskIDGroup(totalNum);
			TaskID[] taskIDs = new TaskID[totalNum];
			
			for (int i=0; i < totalNum; i++) {
				taskIDs[i] = runBM_2(createBenchmark(getBenchmarkClass(benchmarkName)));
			}
			
			for(int i = 0; i < totalNum; i++){
				tig.add(taskIDs[i]);
			}

			try {
				tig.waitTillFinished();
			} catch (ExecutionException e) {
				e.printStackTrace();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			
		} catch (IllegalAccessException e) { 
			e.printStackTrace(); 
		} catch (IllegalArgumentException e) { 
			e.printStackTrace(); 
		} catch (InvocationTargetException e) { 
			e.printStackTrace(); 
		} 
	}
	
	TASK private static void runBM_2(Benchmark benchmark) {
		try { 
			System.out.println("One-off Task [Thread ID "+CurrentTask.currentThreadID()+"] [Thread Local ID "+CurrentTask.currentThreadLocalID()+"] [Task Global ID "+CurrentTask.globalID()+"]  [Task Relative ID "+CurrentTask.relativeID()+"]  [Multi Task Size "+CurrentTask.multiTaskSize()+"] ");
			benchmark.getMethod().invoke(benchmark.getInstance(), benchmark.getArguments()); 
			
			TaskIDGroup tig = new TaskIDGroup(totalNum);
			TaskID[] taskIDs = new TaskID[totalNum];
			
			for (int i=0; i < totalNum; i++) {
				taskIDs[i] = runBM_4(createBenchmark(getBenchmarkClass(benchmarkName)));
			}
			
			for(int i = 0; i < totalNum; i++){
				tig.add(taskIDs[i]);
			}

			try {
				tig.waitTillFinished();
			} catch (ExecutionException e) {
				e.printStackTrace();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			
		} catch (IllegalAccessException e) { 
			e.printStackTrace(); 
		} catch (IllegalArgumentException e) { 
			e.printStackTrace(); 
		} catch (InvocationTargetException e) { 
			e.printStackTrace(); 
		} 
	}
	
	TASK private static void runBM_3(Benchmark benchmark) {
		try { 
			System.out.println("One-off Task [Thread ID "+CurrentTask.currentThreadID()+"] [Thread Local ID "+CurrentTask.currentThreadLocalID()+"] [Task Global ID "+CurrentTask.globalID()+"]  [Task Relative ID "+CurrentTask.relativeID()+"]  [Multi Task Size "+CurrentTask.multiTaskSize()+"] ");
			benchmark.getMethod().invoke(benchmark.getInstance(), benchmark.getArguments()); 
			
			TaskIDGroup tig = new TaskIDGroup(totalNum);
			TaskID[] taskIDs = new TaskID[totalNum];
			
			for (int i=0; i < totalNum; i++) {
				taskIDs[i] = runBM_4(createBenchmark(getBenchmarkClass(benchmarkName)));
			}
			
			for(int i = 0; i < totalNum; i++){
				tig.add(taskIDs[i]);
			}

			try {
				tig.waitTillFinished();
			} catch (ExecutionException e) {
				e.printStackTrace();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			
		} catch (IllegalAccessException e) { 
			e.printStackTrace(); 
		} catch (IllegalArgumentException e) { 
			e.printStackTrace(); 
		} catch (InvocationTargetException e) { 
			e.printStackTrace(); 
		} 
	}
	
	TASK private static void runBM_4(Benchmark benchmark) {
		try { 
			System.out.println("One-off Task [Thread ID "+CurrentTask.currentThreadID()+"] [Thread Local ID "+CurrentTask.currentThreadLocalID()+"] [Task Global ID "+CurrentTask.globalID()+"]  [Task Relative ID "+CurrentTask.relativeID()+"]  [Multi Task Size "+CurrentTask.multiTaskSize()+"] ");
			benchmark.getMethod().invoke(benchmark.getInstance(), benchmark.getArguments()); 
		} catch (IllegalAccessException e) { 
			e.printStackTrace(); 
		} catch (IllegalArgumentException e) { 
			e.printStackTrace(); 
		} catch (InvocationTargetException e) { 
			e.printStackTrace(); 
		} 
	}
	
	private static void runSubTask(Benchmark benchmark) {
		try { 
			benchmark.getMethod().invoke(benchmark.getInstance(), benchmark.getArguments()); 
		} catch (IllegalAccessException e) { 
			e.printStackTrace(); 
		} catch (IllegalArgumentException e) { 
			e.printStackTrace(); 
		} catch (InvocationTargetException e) { 
			e.printStackTrace(); 
		} 
	}

	private static int[] random_serial(int limit) {
		int[] result = new int[limit];
		for (int i = 0; i < limit; i++)
			result[i] = i;
		int w;
		Random rand = new Random();
		for (int i = limit - 1; i > 0; i--) {
			w = rand.nextInt(i);
			int t = result[i];
			result[i] = result[w];
			result[w] = t;
		}
		return result;
	}

	private static ConcurrentLinkedQueue<Benchmark> createBenchmarkSet(Class<?> bmClass, Integer setLen) {
		concurrentLinkedQueue = new ConcurrentLinkedQueue<Benchmark>();
		for (int i = 0; i < setLen; i++) {
			Object benchmark = null;
			Method method = null;
			try {
				benchmark = bmClass.newInstance();
				method = bmClass.getMethod(BM_METHOD, BM_METHOD_ARGUEMENT_TYPE);
			} catch (InstantiationException e) {
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				e.printStackTrace();
			} catch (NoSuchMethodException e) {
				e.printStackTrace();
			} catch (SecurityException e) {
				e.printStackTrace();
			} catch (IllegalArgumentException e) {
				e.printStackTrace();
			}
			Object[] arguments = new Object[1];
			arguments[0] = N_DATASIZE;

			concurrentLinkedQueue.add(new Benchmark(benchmark, method, arguments));

		}
		return concurrentLinkedQueue;
	}
	
	private static Benchmark createBenchmark(Class<?> bmClass) {
		Object benchmark = null;
		Method method = null;
		try {
			benchmark = bmClass.newInstance();
			method = bmClass.getMethod(BM_METHOD, BM_METHOD_ARGUEMENT_TYPE);
		} catch (InstantiationException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		} catch (NoSuchMethodException e) {
			e.printStackTrace();
		} catch (SecurityException e) {
			e.printStackTrace();
		} catch (IllegalArgumentException e) {
			e.printStackTrace();
		}
		Object[] arguments = new Object[1];
		arguments[0] = N_DATASIZE;

		return new Benchmark(benchmark, method, arguments);
	}

	private static Class<?> getBenchmarkClass(String bmName) {

		Class<?> bmClass = null;

		try {
			if (bmName.equalsIgnoreCase(MOL)) {
				bmClass = Class.forName(MOL_CLASS);
			} else if (bmName.equalsIgnoreCase(MON)) {
				bmClass = Class.forName(MON_CLASS);
			} else if (bmName.equalsIgnoreCase(RAY)) {
				bmClass = Class.forName(RAY_CLASS);
			} else {
				throw new Exception("Can not find the Benchmark " + bmName);
			}
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		}

		return bmClass;
	}
}