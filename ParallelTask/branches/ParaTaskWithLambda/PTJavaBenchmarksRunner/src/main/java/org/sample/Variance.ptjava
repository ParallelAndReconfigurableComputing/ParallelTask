package org.sample;

import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.*;

import pt.runtime.TaskIDGroup;
import pt.runtime.ParaTask.ScheduleType;
import pt.runtime.ParaTask.ThreadPoolType;

public class Variance {

    private static final Random rand = new Random();
    private static final int MIN = 1;
    private static final int MAX = 140;
    private static final int POPULATION_SIZE = 90000000;

    public static long THRESHOLD = 1000;
    
    public static void init() {
    	population = generatePopulation(POPULATION_SIZE);
    }
    
    public static double[] generatePopulation(int populationSize) {
    	ParaTask.init();
    	
    	double[] data = new double[populationSize];
    	for(int i = 0; i < populationSize; ++i) {
    		data[i] = randInt();
    	}
    	return data;
    }
    
    private static double[] population;
    
    public static void main(String... args) {
// generate a population with different ages
        population = generatePopulation(POPULATION_SIZE);
        
        computeMeanParaTask(2, ScheduleType.WorkSharing);
        computeMeanParaTask(7, ScheduleType.WorkSharing);
        
        //System.out.println("varianceImperative: " + varianceImperative());
        //System.out.println("varianceParaTaskWithLambda: " + varianceParaTask());
        
        //System.out.println("Imperative version done in: " + measurePerf(Variance::varianceImperative, population) + " msecs" );
        //System.out.println("Parallel streams version done in : " + measurePerf(Variance::varianceStreams, population) + " msecs");
        //System.out.println("ForkJoin version done in : " + measurePerf(Variance::varianceForkJoin, population) + " msecs");
    }

    public static int randInt() {
        return rand.nextInt((MAX - MIN) + 1) + MIN;
    }

    public static double varianceImperative(){
        double average = 0.0;
        for(double p: population){
            average += p;
        }
        average /= population.length;

        double variance = 0.0;
        for(double p: population){
            variance += (p - average) * (p - average);
        }
        return variance / population.length;
    }

    private static double getResult(TaskID<Double> t) {
    	Double result = null;
		try {
			result = t.getReturnResult();
		} catch (Exception e) {
			throw new ParaTaskRuntimeException(e.getMessage());
		}
		return result;
	}
    
    public static double varianceParaTask() {
    	double total = computeSum(0, population.length);
    	double mean = total / population.length;
    	double varSum = computeVarianceSum(0, population.length, mean);
    	return varSum / population.length;
    }
    
    public static void varianceWithThreshold(int numThreads, 
    		ScheduleType schedule, int threshold) {
    	ParaTask.setScheduling(schedule);
    	ParaTask.setThreadPoolSize(ThreadPoolType.ALL, numThreads);
    	THRESHOLD = threshold;
    	varianceParaTask();
    }

    public static double meanRecusive(int numThreads, 
    		ScheduleType schedule, int threshold) {
    	ParaTask.setScheduling(schedule);
    	ParaTask.setThreadPoolSize(ThreadPoolType.ONEOFF, numThreads);
    	
    	if(numThreads == 1) {
    		double total = 0;
            for (int i = 0; i < population.length; i++) {
                total += population[i];
            }
            return total / population.length;
    	}
    	    	
    	THRESHOLD = threshold;
    	double total = computeSum(0, population.length);
    	return total / population.length;
    }
    
    private static double computeSum(int start, int end) {
    	int length = end - start;
        if (length <= THRESHOLD) {
        	double total = 0;
            for (int i = start; i < end; i++) {
                total += population[i];
            }
            return total;
        }

        TaskID<Double> left = computeSumTask(start, start + length/2);
        
        double rightSum = computeSum(start + length/2, end);
        
    	return getResult(left) + rightSum;
    }    
    
    TASK private static double computeSumTask(int start, int end) {
    	return computeSum(start, end);
    }
    
    TASK private static double computeVarianceSumTask(int start, int end, double mean) {
    	return computeVarianceSum(start, end, mean);
    }
    
    private static double computeVarianceSum(int start, int end, double mean) {
    	int length = end - start;
        if (length <= THRESHOLD) {
        	double variance = 0;
            for (int i = start; i < end; i++) {
                variance += (population[i] - mean) * (population[i] - mean);
            }
            return variance;
        }

        TaskID<Double> left = computeVarianceSumTask( 
        		start, start + length/2, mean);
        
        double rightSum = computeVarianceSum(start + length/2, end, mean);
        
    	return getResult(left) + rightSum;
    }
    
    TASK private static double computeNewSumTask(int start, int end) {
    	double total = 0;
        for (int i = start; i < end; i++) {
            total += population[i];
        }
        return total;
    }
    
    public static double computeMeanParaTask(int numThreads, ScheduleType schedule) {
    	ParaTask.setScheduling(schedule);
    	ParaTask.setThreadPoolSize(ThreadPoolType.ALL, numThreads);
    	if(numThreads == 1) {
    		double total = 0;
            for (int i = 0; i < population.length; i++) {
                total += population[i];
            }
            return total / population.length;
    	}
    	
    	int lenPerTask = population.length / numThreads;
    	TaskIDGroup<Double> group = new TaskIDGroup<Double>(numThreads - 1);
    	
    	int start = 0;
    	for(int i = 0; i < numThreads - 1; i++) {
    		TaskID<Double> sum = computeNewSumTask(start, start + lenPerTask);
    		start += lenPerTask;
    		group.add(sum);
    	}

    	double sum = 0;
    	for(int i = start; i < population.length; ++i) {
    		sum += population[i];
    	}
    	try {
    		group.waitTillFinished();
    		
    		Reduction<Double> red = new Reduction<Double>() {
				@Override
				public Double combine(Double a, Double b) {
					return a + b;
				}
            };    		    
            
            sum += group.reduce(red);
                        
            return sum / population.length;
            
    	} catch (Exception e) {
			throw new RuntimeException(e.getMessage());
		}
    }
    
}
